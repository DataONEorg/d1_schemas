<?xml version="1.0" encoding="UTF-8"?>
<xs:schema  targetNamespace="http://ns.dataone.org/service/types/v1"
    xmlns:d1="http://ns.dataone.org/service/types/v1"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    version="0.6.3"
    elementFormDefault="unqualified" attributeFormDefault="unqualified">

<!-- ************************************
        DEFINE REUSABLE SIMPLE TYPES HERE 
        ************************************ -->
    
    <!-- Checksum Algorithm -->
    <xs:simpleType name="ChecksumAlgorithm">
        <xs:restriction base="xs:string">
            <xs:enumeration value="SHA-1"/>
            <xs:enumeration value="SHA-224"/>
            <xs:enumeration value="SHA-256"/>
            <xs:enumeration value="SHA-384"/>
            <xs:enumeration value="SHA-512"/>
            <xs:enumeration value="MD5"/>
        </xs:restriction>
    </xs:simpleType> 
    
    <!-- ComponentName -->
    <xs:simpleType name="ComponentName">
        <xs:restriction base="xs:string">
            <xs:enumeration value="Apache"/>
            <xs:enumeration value="CoordinatingNode"/>
            <xs:enumeration value="Django"/>
            <xs:enumeration value="LinuxUbuntu"/>
            <xs:enumeration value="LinuxDebian"/>
            <xs:enumeration value="MemberNode"/>
            <xs:enumeration value="Mercury"/>
            <xs:enumeration value="Metacat"/>
        </xs:restriction>
    </xs:simpleType>
    
    <!-- ComponentVersion -->
    <xs:simpleType name="ComponentVersion">
        <xs:restriction base="d1:NonEmptyString"/>
    </xs:simpleType>
    
    <!-- crontrabEntry -->
    <xs:simpleType name="CrontabEntry">
        <xs:restriction base="xs:token">
            <xs:pattern value="([\*\d]{1,2}[\-,]?)+"/>
        </xs:restriction>
    </xs:simpleType> 
    
    <!-- Event Enumeration -->
    <xs:simpleType name="Event">
      <xs:annotation>
      <xs:documentation>The controlled list of events that are logged, 
      which will include 'CREATE', 'UPDATE', 'DELETE', 'READ', 'REPLICATE', and
      'SYNCHRONIZATION_FAILED' events.</xs:documentation>
      </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="create"/>
            <xs:enumeration value="read"/>
            <xs:enumeration value="update"/>
            <xs:enumeration value="delete"/>
            <xs:enumeration value="replicate"/>
            <xs:enumeration value="synchronization_failed"/>
        </xs:restriction>
    </xs:simpleType>
    
    <!-- Node State -->
    <xs:simpleType name="NodeState">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="up"/>
            <xs:enumeration value="down"/>
            <xs:enumeration value="unknown"/>
        </xs:restriction>
    </xs:simpleType>
    
    <!-- Node Type Enumeration -->
    <xs:simpleType name="NodeType">
        <xs:restriction base="xs:NMTOKEN">
            <xs:enumeration value="mn"/>
            <xs:enumeration value="cn"/>
            <xs:enumeration value="Monitor"/>
        </xs:restriction>
    </xs:simpleType>
    
    <!-- Non-Empty String -->
    <xs:simpleType name="NonEmptyString">
      <xs:annotation>
      <xs:documentation>A derived string type with at least length 1 and it must contain non-whitespace.</xs:documentation>
      </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:minLength value="1"/>
            <xs:pattern value="[\s]*[\S][\s\S]*"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- Object Format Identifier -->
    <xs:simpleType name="ObjectFormatIdentifier">
        <xs:annotation>
          <xs:documentation> An ObjectFormatIdentifier is a string identifying
          the object format. It must be unique in the containing ObjectFormatList.
          </xs:documentation>
        </xs:annotation>
        <xs:restriction base="d1:NonEmptyString"></xs:restriction>
    </xs:simpleType>
        
    <!-- Permission = permitted action -->
    <xs:simpleType name="Permission">
      <xs:annotation>
        <xs:documentation>A string value indicating the set of actions that can be performed on a
  resource as specified in an access policy.  The set of permissions include
  the ability to read a resource, modify a resource (write), and to change
  the set of access control policies for a resource (changePermission).  In
  addition, there is a permission that controls ability to execute a service
  (execute). Permissions are cumulative, in that higher level permissions
  include all of the priveledges of lower levels (e.g., given write access, one
  also implicitly has read access).</xs:documentation>
      </xs:annotation>
      <xs:restriction base="xs:string">
        <xs:enumeration value="read"/>
        <xs:enumeration value="write"/>
        <xs:enumeration value="changePermission"/>
        <xs:enumeration value="execute"/>
      </xs:restriction>
    </xs:simpleType>
    
    <!-- QueryType = named types of search query formats -->
    <xs:simpleType name="QueryType">
      <xs:annotation>
        <xs:documentation>A string value indicating the type of a query from a controlled list.
                          The types of queries will expand with subsequent release versions, but
                          the CN will only support certain query types for search during any particular
                          release.
        </xs:documentation>
      </xs:annotation>
      <xs:restriction base="xs:string">
        <xs:enumeration value="SOLR"/>
        <xs:enumeration value="ECOGRID"/>
      </xs:restriction>
    </xs:simpleType>
    
    <!-- Replication Status enumeration -->
    <xs:simpleType name="ReplicationStatus">
        <xs:restriction base="xs:string">
            <xs:enumeration value="queued"/>
            <xs:enumeration value="requested"/>
            <xs:enumeration value="completed"/>
            <xs:enumeration value="invalidated"/>
        </xs:restriction>
    </xs:simpleType>
    
    <!-- Identifier Format enumeration -->
    <xs:simpleType name="IdentifierFormat">
      <xs:annotation>
        <xs:documentation>Initially an enumerated list of strings that specify different types of identifiers.
        </xs:documentation>
      </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="OID"/>
            <xs:enumeration value="LSID"/>
            <xs:enumeration value="UUID"/>
            <xs:enumeration value="LSRN"/>
            <xs:enumeration value="DOI"/>
            <xs:enumeration value="URI"/>
            <xs:enumeration value="STRING"/>
        </xs:restriction>
    </xs:simpleType>

    <!-- Service Name -->
    <xs:simpleType name="ServiceName">
        <xs:restriction base="d1:NonEmptyString"/>
    </xs:simpleType>
    
    
    <!-- Service Version -->
    <xs:simpleType name="ServiceVersion">
        <xs:restriction base="d1:NonEmptyString"/>
    </xs:simpleType>

    <!-- ***************************************
            DEFINE REUSABLE COMPLEX  TYPES HERE 
            *************************************** -->
    
    <!-- NOTE THAT ALL SERIALIZEABLE ROOT ELEMENTS FOR MESSAGES SHOULD BE OF A COMPLEX TYPE -->

    <!-- AccessPolicy -->
    <xs:complexType name="AccessPolicy">
        <xs:sequence>
            <xs:element name="allow" type="d1:AccessRule" 
                minOccurs="1" maxOccurs="unbounded" />
        </xs:sequence>
    </xs:complexType>
    
    <!-- AccessRule -->
    <xs:complexType name="AccessRule">
        <xs:sequence>
        	<xs:element name="subject" type="d1:Subject" 
        	            minOccurs="1" maxOccurs="unbounded" />
        	<xs:element name="permission" type="d1:Permission" 
        	            minOccurs="1" maxOccurs="unbounded" />
        </xs:sequence>
    </xs:complexType>
    
    <!-- Checksum -->
    <xs:complexType name="Checksum">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="algorithm" type="d1:ChecksumAlgorithm"
                    use="required"/>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
  
    <!-- Component -->
    <xs:complexType name="Component">
        <xs:annotation>
            <xs:documentation>Name and version of a DataONE software stack component.
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="name" type="d1:ComponentName" use="required"/>
        <xs:attribute name="version" type="d1:ComponentVersion" use="required"/>
    </xs:complexType>
    
    <!-- Component List -->
    <xs:complexType name="ComponentList">
        <xs:annotation>
            <xs:documentation>A ComponentList is the structure returned
                from the version() method. It provides a list of DataONE software stack
                components and their corresponding version numbers.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="component" type="d1:Component"/>
        </xs:sequence>
    </xs:complexType>

    <!-- Group -->
    <xs:complexType name="Group">
        <xs:sequence>
            <xs:element name="subject" type="d1:Subject" 
                minOccurs="1" maxOccurs="1" />
            <xs:element name="groupName" type="d1:NonEmptyString" 
                minOccurs="1" maxOccurs="1" />
            <xs:element name="hasMember" type="d1:Subject" 
                minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
    </xs:complexType>
    
    <!-- Identifier  -->
    <xs:complexType name="Identifier">
        <xs:annotation>
          <xs:documentation>An :term:`identifier` (:term:`PID`) in the DataONE system. This is
                            equivalent to a Unicode string of printable characters, excluding
                            whitespace. All representations of identifiers must be encoded in 7-bit
                            ASCII or UTF-8.
          </xs:documentation>
          <xs:documentation>Identifiers have a maximum length of 800 characters. Some discussion on this
                            is described in `ticket 577`_.
          </xs:documentation>
          <xs:documentation>.. _ticket 577: https://redmine.dataone.org/issues/577
          </xs:documentation>
        </xs:annotation>
        <xs:simpleContent>
            <xs:extension base="d1:NonEmptyString">
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    
    <!--  Log -->
	<xs:complexType name="Log">
	    <xs:annotation>
	      <xs:documentation>Represents a collection of LogEntry elements, used to transfer log information between DataONE components. 
	      </xs:documentation>    
	    </xs:annotation>
		<xs:complexContent>
			<xs:extension base="d1:Slice">
				<xs:sequence>
					<xs:element name="logEntry" type="d1:LogEntry"
						minOccurs="0" maxOccurs="unbounded" />
				</xs:sequence>
			</xs:extension>
		</xs:complexContent>
	</xs:complexType>
        
    <!-- Log Entry -->
    <xs:complexType name="LogEntry">
        <xs:annotation>
            <xs:documentation>Represents a single log entry resulting from the action of a single event.</xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="entryId" type="d1:Identifier" 
                minOccurs="1" maxOccurs="1"/>
            <xs:element name="identifier" type="d1:Identifier" 
                minOccurs="1" maxOccurs="1"/>
            <xs:element name="ipAddress" type="xs:string"
                minOccurs="1" maxOccurs="1"/>
            <xs:element name="userAgent" type="xs:string"
                minOccurs="1" maxOccurs="1"/>
            <xs:element name="subject" type="d1:Subject"
                minOccurs="1" maxOccurs="1"/>
            <xs:element name="event" type="d1:Event"
                minOccurs="1" maxOccurs="1"/>
            <xs:element name="dateLogged" type="xs:dateTime"
                minOccurs="1" maxOccurs="1"/>
            <xs:element name="memberNode" type="d1:NodeReference"
                minOccurs="1" maxOccurs="1"/>
        </xs:sequence>
    </xs:complexType>
    
    <!-- Monitor Info -->
    <xs:complexType name="MonitorInfo">
        <xs:sequence>
            <xs:element name="date" type="xs:date" minOccurs="1" maxOccurs="1"/>
            <xs:element name="count" type="xs:int" minOccurs="1" maxOccurs="1"/>
        </xs:sequence>
    </xs:complexType>
    
    <!-- Monitor List -->
    <xs:complexType name="MonitorList">
        <xs:sequence>
            <xs:element name="monitorInfo" type="d1:MonitorInfo" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    
    <!-- Node -->
    <xs:complexType name="Node">
        <xs:annotation>
            <xs:documentation>A unique implementation of the member node or coordination node software
                stack. several nodes may exist on a single physical device or hostname 
            </xs:documentation>
        </xs:annotation>
        
        <xs:sequence>
            <xs:element name="identifier" type="d1:NodeReference" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>A unique identifier for the node. This may initially be the same as the
                        baseURL, however this value should not change for future implementations of the same
                        node, whereas the baseURL may change in the future. 
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="name" type="d1:NonEmptyString" minOccurs="1" maxOccurs="1" >
                <xs:annotation>
                    <xs:documentation>A human readable name of the Node. 
                        The name of the node is being used in Mercury currently to assign a path,
                        so format should be consistent with dataone directory naming conventions
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            
            <xs:element name="description" type="d1:NonEmptyString" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>Description of content maintained by this node and any other free style
                        notes. May be we should allow CDATA element with the purpose of using for display
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="baseURL" type="xs:anyURI" minOccurs="1" maxOccurs="1"/>
            <xs:element name="services" type="d1:Services" minOccurs="0" maxOccurs="1"/>
            <xs:element name="synchronization" type="d1:Synchronization" minOccurs="0" maxOccurs="1"/>
            <xs:element name="health" type="d1:NodeHealth" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>The name of the node is being used in Mercury currently to assign a
                        path, so format should be consistent with dataone directory naming conventions
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        
        <xs:attribute name="replicate" use="required" type="xs:boolean"/>
        <xs:attribute name="synchronize" use="required" type="xs:boolean"/>
        <xs:attribute name="type" use="required" type="d1:NodeType"/>
        
    </xs:complexType>
    
    <!-- Node Health -->
    <xs:complexType name="NodeHealth">
        <xs:annotation>
            <xs:documentation>The schedule on which MnSynchronization will run for a particular run
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="ping" type="d1:Ping" />
            <xs:element name="status"   type="d1:Status" />
        </xs:sequence>
        
        <xs:attribute name="state" type="d1:NodeState" use="required"/>
    </xs:complexType>
    
    <!-- Node List -->  
    <xs:complexType name='NodeList'>
        <xs:sequence>
            <xs:element maxOccurs="unbounded" name="node" type="d1:Node" minOccurs="1"/>
        </xs:sequence>
    </xs:complexType>
    
    <!-- NodeReference -->
    <xs:complexType name="NodeReference">
      <xs:annotation>
      <xs:documentation>Member Node identifier drawn from the DataONE :mod:`cn_register &lt;registry service&gt;`.</xs:documentation>
      </xs:annotation>
       <xs:simpleContent>
            <xs:extension base="d1:NonEmptyString">
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>    
    
        <!-- Object Format -->
    <xs:complexType name="ObjectFormat">
      <xs:annotation>
        <xs:documentation>An ObjectFormat is the structure returned from the 
        getFormat() method of the CN REST interface.  It provides the 
        unique identifierand the name associated with the object format.  
        Future versions may contain additional structured content from 
        external common typing systems.
        </xs:documentation>
      </xs:annotation>
      <xs:sequence>
        <xs:element name="fmtid" type="d1:ObjectFormatIdentifier" 
          minOccurs="1" maxOccurs="1">
          <xs:annotation>
              <xs:documentation>
                  The unique identifier of the object format in the DataONE
                  Object Format Vocabulary.  The identifier should comply with
                  DataONE Identifier rules, i.e. no whitespace, UTF-8 or 
                  US-ASCII printable characters.
              </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="formatName" type="xs:string" 
          minOccurs="1" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              For objects that are typed using a Document Type Definition, 
              this lists the well-known and accepted named version of the DTD.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="scienceMetadata" type="xs:boolean" 
          minOccurs="1" maxOccurs="1">
          <xs:annotation>
            <xs:documentation>
              A boolean field indicating whether or not this format is science
              metadata describing a science data object.  If the format is a
              self-describing data format that includes science metadata, then 
              the field should also be set to true.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        
      </xs:sequence>
    </xs:complexType>    
    
    <!--  Object Format List -->
    <xs:complexType name="ObjectFormatList">
      <xs:annotation>  
        <xs:documentation>An ObjectFormatList is the structure returned from 
        the listFormats() method of the CN REST interface.  It provides a list 
        of named objectformats defined in the DataONE system.  Each 
        ObjectFormat returned in the list describes the object format via its 
        name, and future versions may contain additional structured content 
        from common external typing systems.
        </xs:documentation>
      </xs:annotation>    
      <xs:complexContent>
        <xs:extension base="d1:Slice">
          <xs:sequence>
            <xs:element name="objectFormat" type="d1:ObjectFormat"
              minOccurs="1" maxOccurs="unbounded" />
          </xs:sequence>
        </xs:extension>
      </xs:complexContent>
    </xs:complexType>
    
    <!-- Object Info -->
    <xs:complexType name="ObjectInfo">
        <xs:sequence>
            <xs:element name="identifier"  type="d1:Identifier" minOccurs="1" maxOccurs="1"/>
            <xs:element name="objectFormat" type="d1:ObjectFormat"/>
            <xs:element name="checksum" type="d1:Checksum"
                minOccurs="1" maxOccurs="1" />
            <xs:element name="dateSysMetadataModified" type="xs:dateTime"/>
            <xs:element name="size" type="xs:long"/>
            
        </xs:sequence>
    </xs:complexType>
    
    <!-- Object List -->
    <xs:complexType name="ObjectList" >
        <xs:complexContent>
            <xs:extension base="d1:Slice">
                <xs:sequence>
                    <xs:element name="objectInfo" type="d1:ObjectInfo" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    
    <!-- Object Location -->
    <xs:complexType name="ObjectLocation">
        <xs:sequence>
            <xs:element name="nodeIdentifier" type="d1:NodeReference"
                minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>Identifier of the node (the same identifier used
                        in the node registry for identifying the node.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="baseURL" minOccurs="1" maxOccurs="1" type="xs:anyURI">
                <xs:annotation>
                    <xs:documentation>The current base URL for services implemented on the target node.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="url" minOccurs="1" maxOccurs="1" type="xs:anyURI">
                <xs:annotation>
                    <xs:documentation>The full (absolute) URL that can be used to
                        retrieve the object using the get() method of the rest interface.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="preference" minOccurs="0" maxOccurs="1" type="xs:int">
                <xs:annotation>
                    <xs:documentation>A weighting parameter that provides a hint to the caller 
                        for the relative preference for nodes from which the content should be retrieved.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    
    <!-- Object Location List -->
    <xs:complexType name="ObjectLocationList">
        <xs:annotation>
            <xs:documentation>An ObjectLocationList is the structure returned
                from the resolve() method of the CN REST interface. It provides a
                list of locations from which the specified object can be retrieved.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="identifier" type="d1:Identifier"
                minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>The identifier of the object being resolved.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="objectLocation" type="d1:ObjectLocation"
                minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>List of nodes from which the object can be
                        retrieved</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>
    
    <!-- Person -->
    <xs:complexType name="Person">
        <xs:sequence>
            <xs:element name="subject" type="d1:Subject" 
                minOccurs="1" maxOccurs="1" />
            <xs:element name="givenName" type="d1:NonEmptyString" 
                minOccurs="1" maxOccurs="unbounded" />
            <xs:element name="familyName" type="d1:NonEmptyString" 
                minOccurs="1" maxOccurs="1" />
            <xs:element name="email" type="d1:NonEmptyString" 
                minOccurs="1" maxOccurs="unbounded" />
            <xs:element name="isMemberOf" type="d1:Subject" 
                minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="equivalentIdentity" type="d1:Subject" 
                minOccurs="0" maxOccurs="unbounded" />
            <!-- Do we need further Person metadata?
            <xs:element name="institution" type="d1:NonEmptyString"
                minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="department" type="d1:NonEmptyString"
                minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="address1" type="d1:NonEmptyString"
                minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="address2" type="d1:NonEmptyString"
                minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="city" type="d1:NonEmptyString"
                minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="state" type="d1:NonEmptyString"
                minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="zip" type="d1:NonEmptyString"
                minOccurs="0" maxOccurs="unbounded"/>
            -->
        </xs:sequence>
    </xs:complexType>

    <!-- Ping -->
    <xs:complexType name="Ping">
        <xs:annotation>
            <xs:documentation>Store results from the Mn_Health.ping method
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="success" type="xs:boolean" />
        <xs:attribute name="lastSuccess" type="xs:dateTime" />
    </xs:complexType>

    <!-- Replica -->
    <xs:complexType name="Replica">
        <xs:sequence>
            <xs:element name="replicaMemberNode" type="d1:NodeReference"/>
            <xs:element name="replicationStatus" type="d1:ReplicationStatus" />
            <xs:element name="replicaVerified" type="xs:dateTime"/>
        </xs:sequence>
    </xs:complexType>
    
    
   <!-- Replication Policy -->
    <xs:complexType name="ReplicationPolicy">
        <xs:sequence>
            <xs:element name="preferredMemberNode" type="d1:NodeReference"
                minOccurs="0" maxOccurs="unbounded">
            <xs:annotation>
                <xs:documentation>Nodes listed here have preference over other nodes for 
                    replication targets.
                </xs:documentation>
            </xs:annotation>    
            </xs:element>
            <xs:element name="blockedMemberNode" type="d1:NodeReference"
                minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>The object MUST never be replicated to nodes 
                        listed as blockedMemberNodes. Where there is a conflict between 
                        a requiredMemberNode and a blockedMemberNode entry, the 
                        blockedMemberNode entry prevails.
                    </xs:documentation>
                </xs:annotation>                
            </xs:element>
        </xs:sequence>
        <xs:attribute name="replicationAllowed" type="xs:boolean" />
        <xs:attribute name="numberReplicas" type="xs:int"/>
    </xs:complexType>
    
    <!-- Service -->
    <xs:complexType  name="Service">
        <xs:annotation>
            <xs:documentation>The available Dataone Service APIs that are exposed on a Node
                Name and version of a DataONE software stack component are
                equivalent to the statusresponselist.xsd name and version. 
                Without a restriction, all service methods are available to all callers.
                Restrictions may be placed on individual methods of the service to limit 
                the service to a certain set of Subjects.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
	        <xs:element name="name" type="d1:ServiceName" minOccurs="1" maxOccurs="1" />
	        <xs:element name="restriction" type="d1:ServiceMethodRestriction" minOccurs="0" maxOccurs="unbounded" />
	    </xs:sequence>    
        <xs:attribute name="version" type="d1:ServiceVersion" use="required"/>
        <xs:attribute name="available" type="xs:boolean"/>
        
    </xs:complexType>
    
    <!-- Service Method Restriction -->
    <xs:complexType  name="ServiceMethodRestriction">
        <xs:annotation>
            <xs:documentation>Describes the restriction policy for a given method.
                Only subjects listed in the allowed list are allowed to invoke the method.
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
        	<xs:element name="allowed" type="d1:SubjectList" minOccurs="1" maxOccurs="1" />
        </xs:sequence>
        <xs:attribute name="name"  type="xs:NMTOKEN" />
        <xs:attribute name="rest" use="required"  type="xs:token"/>
    </xs:complexType>
    
    <!-- Services -->
    <xs:complexType  name="Services">
        <xs:sequence>
            <xs:element name="service" type="d1:Service" minOccurs="1" maxOccurs="unbounded" />
        </xs:sequence>
    </xs:complexType>
    
    <!-- Session -->
    <xs:complexType  name="Session">
        <xs:annotation>
            <xs:documentation>Information about the authenticated session for a service transaction.  Session data
                              is retrieved from the SSL client certificate and populated in the Session object.  The
                              subject represents the person or system that authenticated successfully, and the subjectList
                              contains a listing of alternate identities (both Persons and Groups) that are also valid identities
                              for this user.  The subjectList should include at least one Person or Group entry that provides
                              the attributes of the subject that was authenticated. 
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="subject" type="d1:Subject" minOccurs="1" maxOccurs="1" />
            <xs:element name="subjectList" type="d1:SubjectList" minOccurs="0" maxOccurs="1" />
        </xs:sequence>
    </xs:complexType>
    
    <!-- Schedule -->
    <xs:complexType name="Schedule">
        <xs:annotation>
            <xs:documentation>The schedule on which MnSynchronization will run for a particular run
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="hour" use="required" type="d1:CrontabEntry"/>
        <xs:attribute name="mday" use="required" type="d1:CrontabEntry"/>
        <xs:attribute name="min"  use="required" type="d1:CrontabEntry"/>
        <xs:attribute name="mon"  use="required" type="d1:CrontabEntry"/>
        <xs:attribute name="sec"  use="required" type="d1:CrontabEntry"/>
        <xs:attribute name="wday" use="required" type="d1:CrontabEntry"/>
        <xs:attribute name="year" use="required" type="d1:CrontabEntry"/>
    </xs:complexType>
    
    <!-- Slice -->
    <xs:complexType name="Slice">
        <xs:attribute name="count" use="required" type="xs:int"/>
        <xs:attribute name="start" use="required" type="xs:int"/>
        <xs:attribute name="total" use="required" type="xs:int"/>
    </xs:complexType>
    
    <!-- Status -->
    <xs:complexType name="Status">
        <xs:annotation>
            <xs:documentation>Store last time checked information from the Mn_Health.status method
                Other information from status will be stored in the Service Node
                A process should check  MN_health.getStatus()  periodically and  
                update the version and availability  for each service.
            </xs:documentation>
        </xs:annotation>
        <xs:attribute name="success" type="xs:boolean" />
        <xs:attribute name="dateChecked" use="required" type="xs:dateTime"/>
    </xs:complexType>
    
    <!-- Synchronization -->
    <xs:complexType name="Synchronization">
        <xs:annotation>
            <xs:documentation>The process by which data is pulled from membernodes down
                to the coordinating node
            </xs:documentation>
        </xs:annotation>
        <xs:sequence>
            <xs:element name="schedule" type="d1:Schedule" minOccurs="1" maxOccurs="1"/>
            <xs:element name="lastHarvested" type="xs:dateTime" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>The last time the mn sychronization daemon ran and found new data to synchronize
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="lastCompleteHarvest" type="xs:dateTime" minOccurs="1" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>The last time all the data from a node was pulled from a member node
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <!-- Subject = user identity -->
    <xs:complexType name="Subject">
      <xs:annotation>
        <xs:documentation>Person (user), Group, or Organization, or System.</xs:documentation>
        <xs:documentation>The formal name identifiying a user or group from the DataONE 
  Identity Management Service. The subject is represented by a unique,
  persistent, non-reassignable identifier string that follows the same
  constraints as Identifier.</xs:documentation>
        <xs:documentation>Used by :mod:`SystemMetadata`</xs:documentation>
      </xs:annotation>
       <xs:simpleContent>
            <xs:extension base="d1:NonEmptyString">
        <!-- Note: Can also be special names:
        	 VerifiedUser: anyone with checked credentials for whom their real name and email has been verified
             AuthenticatedUser: anyone with checked credentials
             Public: anyone, whether authenticated or not
        -->
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
    
    <!-- SubjectList -->
    <xs:complexType name="SubjectList">
        <xs:sequence>
            <xs:element name="person" type="d1:Person"
                minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="group" type="d1:Group"
                minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
        
    <!-- Definition of the SystemMetdata element -->
    <xs:complexType name="SystemMetadata">
        <xs:sequence>
            <!-- Client Provided system metadata fields -->
            <xs:element name="identifier" type="d1:Identifier"/>
            <xs:element name="objectFormat" type="d1:ObjectFormat"/>
            <xs:element name="size" type="xs:long"/>
            <xs:element name="checksum" type="d1:Checksum"/>
            
            <xs:element name="submitter" type="d1:Subject"/>
            <xs:element name="rightsHolder" type="d1:Subject"/>
            <xs:element name="accessPolicy" type="d1:AccessPolicy"
                minOccurs="0" maxOccurs="1" />
            <xs:element name="replicationPolicy" type="d1:ReplicationPolicy"
                minOccurs="0" maxOccurs="1" />
            
            <xs:element name="obsoletes" type="d1:Identifier" minOccurs="0" maxOccurs="1"/>
            <xs:element name="obsoletedBy" type="d1:Identifier" minOccurs="0" maxOccurs="1"/>
            <xs:element name="resourceMap" type="d1:Identifier" minOccurs="0"
                maxOccurs="unbounded"/>
                            
            <xs:element name="dateUploaded" type="xs:dateTime"/>
            <xs:element name="dateSysMetadataModified" type="xs:dateTime"/>            
            <xs:element name="originMemberNode" type="d1:NodeReference"/>
            <xs:element name="authoritativeMemberNode" type="d1:NodeReference"/>
            <xs:element name="replica" maxOccurs="unbounded" minOccurs="0" type="d1:Replica" />
        </xs:sequence>
    </xs:complexType>
    
    <!-- ******************************************
            DEFINE ROOT ELEMENTS OF MESSAGES HERE 
            ****************************************** -->
    <!-- NOTE THAT ALL SERIALIZEABLE ROOT ELEMENTS FOR MESSAGES SHOULD BE OF A COMPLEX TYPE -->   
    
    <!-- access policy -->
    <xs:element name="accessPolicy" type="d1:AccessPolicy" />

    <!-- checksum root element for Checksum messages-->
    <xs:element name="checksum" type="d1:Checksum" />
    
    <xs:element name="componentList" type="d1:ComponentList" />
    
    <!-- identifier root element for Identifier messages -->
    <xs:element name="identifier" type="d1:Identifier" />
    
    <!-- Definition of the Logging element -->
    <xs:element name="log" type="d1:Log" />
        
    <xs:element name="monitorList" type="d1:MonitorList" />
    
    <xs:element name='nodeList' type="d1:NodeList"/>
    
    <xs:element name="objectList" type="d1:ObjectList" />
    
    <xs:element name="objectLocationList" type="d1:ObjectLocationList" />
        
    <xs:element name="objectFormat" type="d1:ObjectFormat" />

    <xs:element name="objectFormatList" type="d1:ObjectFormatList" />
    
    <xs:element name="nodeReference" type="d1:NodeReference" />
    
    <xs:element name="person" type="d1:Person" />

    <xs:element name="subject" type="d1:Subject" />

    <xs:element name="subjectList" type="d1:SubjectList" />

    <xs:element name="systemMetadata" type="d1:SystemMetadata" />
    
</xs:schema>
